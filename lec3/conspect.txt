
# Context and Encapsulation

**Context** is a scope that can encapsulate data. It can be:

1. Module  
2. Class/Struct  
3. Function  
4. Private member

**Context can encapsulate data within itself.**

Examples:

- A `static` variable inside a function is **not visible** to anything outside this function.
- A variable local to a module (especially if `static`) is **not accessible** outside the module.
- A `private` member of a class is **not accessible** outside that class.

> üîí "Visible" here means "accessible by name." Technically, in C++ we can still access memory directly (due to linear memory model), but it's unsafe and not recommended.

**Encapsulation (concealment)** is a mechanism of abstraction.  
It's used to **maintain invariants** ‚Äî i.e., to ensure the internal state of an object remains valid throughout its lifetime.

> ‚ö†Ô∏è If an invariant is violated, it may lead to **undefined behavior (UB).**

---

# `malloc` vs `new` ‚Äî Object Lifetime

`malloc` and `free` do **not** know anything about constructors or destructors.  
So when you allocate memory with `malloc`, the object is created in an **inconsistent state**:

- The object's lifetime has begun.
- But its fields are uninitialized or "stateless."

In contrast, **C++ provides the `new` and `delete` keywords** for object creation and destruction.

---

# `new` and `new[]`

There are two types of `new` in C++:

1. `new T` ‚Äî creates a single object  
2. `new T[]` ‚Äî creates an array of objects

## How `new[]` Works Internally

When allocating an array with `new[]`, the compiler typically allocates **a little extra memory** to store the number of elements.  
This number is used later by `delete[]` to know **how many destructors to call**.

Example:
```cpp
int* t = new Widget[5]; // 5 constructors called
delete[] t;             // 5 destructors called


#include <iostream>

struct MySmallClass {
  int t = 1;
  MySmallClass() { std::cout << "small ctor" << std::endl; }
  ~MySmallClass() { std::cout << "small dtor" << std::endl; }
};

struct MyBigClass {
  int t = 1, p = 2, q = 3;
  MyBigClass() { std::cout << "big ctor" << std::endl; }
  ~MyBigClass() { std::cout << "big dtor" << std::endl; }
};

int main () {
  MyBigClass* S = new MyBigClass;
  MySmallClass* s = new MySmallClass;
  MyBigClass* pS = new MyBigClass[5];
  MySmallClass* ps = new MySmallClass[5];

  delete[] s; // ‚ùå TERRIBLY WRONG!
}
```
## Object Lifetime

The lifetime of a variable is the time during which its state is valid.
```
int main() {
  int a = a; // ‚ùå UB ‚Äî a is declared but uninitialized!
}
```

```
int a = 2;

void foo () {
  int b = a + 3;
  int* pc;

  if (b > 5) {
    int c = (a + b) / 2;
    pc = &c; // c goes out of scope here ‚Äî pointer pc becomes dangling!
  }

  b += *pc; // ‚ùå UB ‚Äî using a dangling pointer!
}
```
```
int* p = new int[5];
int& x = p[3];
delete[] p;
x += 1; // ‚ùå UB ‚Äî using a reference to a deleted object!

```
```
int& foo() {
  int x = 42;
  return x; // ‚ùå returning reference to local variable ‚Äî UB
}

int x = foo(); // x refers to expired object
```



